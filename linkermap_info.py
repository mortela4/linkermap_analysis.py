"""
@file linkermap_info.py
@brief Finds .text-entries, sorts them by size.
Writes output to console, and optionally to CSV-file if '-c <filename>' flag specified.
@note Assumes .MAP-file generated by GCC option '-Map=<mafile name>'.
"""

import argparse
import sys
import os


MAX_FUNC_NAME_CHARS = 50    # No-one use >50chars in function names, or ...??


def correct_mapinfo_lines(lines: list, debug: bool = False) -> list:
    corrected_lines = list()
    keep = ''
    for line in lines:
        line = line.strip()
        if line.startswith('.text'):
            fields = line.split()
            if len(fields) == 1:
                keep = line
                continue
            else:
                corrected_lines.append(line)
        elif line.startswith('0x00000000'):
            line = keep + ' ' + line
            corrected_lines.append(line)
        else:
            pass
    #
    if debug:
        for corr_line in corrected_lines:
            print(corr_line)
    #
    return corrected_lines


def get_text_section_entries(mapfile: str, correct_lines: bool = False, debug: bool = False) -> list:
    text_section_lines = list()
    with open(mapfile, 'r') as fp:
        map_lines = fp.readlines()
    #
    if map_lines is None or len(map_lines) == 0:
        print("ERROR: got no lines in input (.MAP) file!")
        return None
    else:
        print("MAP-file size = %d lines ..." % len(map_lines))
    #
    if correct_lines:
        map_lines = correct_mapinfo_lines(map_lines)
    #
    for line in map_lines:
        line = line.strip()
        if line.startswith('.text'):
            text_section_lines.append(line)
            if debug:
                print("INFO: got .text-entry = '%s'" % line)
        else:
            if debug and len(line) != 0:
                print("Rejected line first field: %s" % line)
                pass
    #
    if debug:
        print("DEBUG: got %d .text-lines ..." % len(text_section_lines))
    return text_section_lines


def process_line(line: str, debug: bool = False) -> tuple:
    fields = line.split()
    #
    if len(fields) < 4:
        return None
    #
    func_name = fields[0].split('.')[-1]
    func_hex_size = fields[2]
    func_src_full = fields[3]
    #
    func_src = func_src_full.rstrip('.o') + '.c'
    try:
        func_size = int(func_hex_size, 16)
    except ValueError:
        if debug:
            print("ERROR: could not convert size field = '%s'!" % func_hex_size)
        return None
    #
    if func_size == 0:
        return None
    #
    return func_name, func_size, func_src


def sort_func_entries(entries: list, debug: bool = False) -> list:
    def get_size_field(item: tuple):
        return item[1]
    #
    map_info_list = list()
    for entry in entries:
        map_info = process_line(entry)
        if map_info is not None:
            if debug:
                print("INFO: mapinfo = '%s'" % str(map_info))
            map_info_list.append(map_info)
    #
    sorted_map_info = sorted(map_info_list, key=get_size_field, reverse=True)
    #
    return sorted_map_info


def sort_func_entries_by_module_name(size_sorted_entries: list, debug: bool = False) -> tuple:
    def get_module_name(item: tuple):
        return os.path.basename(item[2])
    #
    modules_dict = dict()
    modules_list = list()
    #
    sorted_map_info = sorted(size_sorted_entries, key=get_module_name)
    #
    current_module_name = ''
    for map_info in sorted_map_info:
        fname, fsize, fsrc = map_info
        #
        module_name = get_module_name(map_info)
        if module_name == current_module_name:
            modules_dict[module_name].append((fname, fsize))
        else:
            modules_dict[module_name] = [(fname, fsize)]
            current_module_name = module_name
            modules_list.append(module_name)
            if debug:
                print("Module name: ", module_name)
    #
    if debug:
        print("\n\nModules list\n=================\n")
        for mname in modules_list:
            print("Module: ", mname)
    #
    return modules_list, modules_dict


def pretty_print_by_module_name(module_list: list, module_dict: dict, show_all: bool = True) -> tuple:
    print("\n\nModules listing")
    print("===================")
    std_lib_funcs = list()
    user_funcs = list()
    user_modules = module_dict
    stdlib_modules = dict()
    #
    print("\nUser-code modules:")
    print("********************")
    for m_entry in module_list:
        m_funcs = module_dict[m_entry]
        if m_entry.startswith('libc') or m_entry.startswith('libgcc') or m_entry.startswith('libm'):
            std_lib_funcs.extend(m_funcs)
            stdlib_modules[m_entry] = m_funcs
            user_modules.pop(m_entry)
            continue
        #
        user_funcs.append(m_funcs)
        print("\nModule '%s' functions:" % m_entry)
        print("---------------------------------------------------------------------------------------------")
        for m_funcname, m_funcsz in m_funcs:
            print("'%s()' = %d bytes" % (m_funcname, m_funcsz))
        print("---------------------------------------------------------------------------------------------\n")
    #
    def get_func_size(item: tuple):
        return item[1]
    #
    std_lib_funcs_sorted = sorted(std_lib_funcs, key=get_func_size, reverse=True)
    #
    # Print std.lib modules conditionally:
    # ------------------------------------
    if show_all:
        print("\nStandard C-library functions:")
        print("********************************")
        for m_funcname, m_funcsz in std_lib_funcs_sorted:
            if m_funcname == 'text':
                print("<optimized asm-sequence> = %d bytes" % m_funcsz)
            else:
                print("'%s()' = %d bytes" % (m_funcname, m_funcsz))
    #
    return user_modules, std_lib_funcs_sorted


def pretty_print_mapinfo(entries: list):
    total_size = 0
    num_functions = len(entries)
    print("Function:                                         Size:\t\tSource file:")
    print("====================================================================================================================================================================================================================")
    for map_info in entries:
        fname, fsize, fsrc = map_info
        #
        console_line = fname
        field_size = MAX_FUNC_NAME_CHARS - len(fname)
        console_line += ' ' * field_size
        console_line += str(fsize)
        console_line += '\t\t'
        console_line += fsrc
        console_line += '\n'
        #
        print(console_line)
        total_size += fsize
    #
    print("\n--------------------------------------------------------------------------------------------------")
    print("Total size: %d bytes" % total_size)
    print("Total # of functions: %d" % num_functions)
    print("--------------------------------------------------------------------------------------------------")


def dump_mapinfo_to_csv(entries: list, csv_name: str):
    csv_entries = list()
    header = "Function Name,Function Size,Source file\n"
    csv_entries.append(header)
    #
    for map_info in entries:
        fname, fsize, fsrc = map_info
        mapinfo_line = fname + ',' + str(fsize) + ',' + fsrc + '\n'
        csv_entries.append(mapinfo_line)
    #
    with open(csv_name, 'w') as fp:
        map_lines = fp.writelines(csv_entries)
    #
    print("\n%d function (.MAP-)entries written to CSV-file '%s' ..." % (len(entries), csv_name))


def print_total(u_modules: dict, mlist: list):
    # Calculate individual numbers
    total_num_modules = len(mlist)
    num_u_modules = len(u_modules)
    num_stdlib_modules = total_num_modules - num_u_modules
    # Print summary:
    print("\n===============================================================================")
    print("**************************** Summary ******************************************")
    print("===============================================================================")
    print("User modules:\t\t\t", num_u_modules)
    print("Std.Lib modules:\t\t", num_stdlib_modules)
    print("Total # of modules:\t\t", total_num_modules)


# *************************** MAIN *********************************
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="'linkermap_info' link-map function size information.\r\n \
                                                   Input required: .MAP-file generated per GCC's linker-format.\r\n \
                                                   Synopsis: 'linkermap_info [-c <csv-file>] <.map-file>'")
    # Required .MAP-file to read linkinfo from:
    parser.add_argument(action='store', dest='map_filename', type=str,
                        help='Linker-map (.MAP) file-name.')
    # Optional CSV-file to write comma-separated data to:
    parser.add_argument('--csv', '-c', action='store', dest='csv_filename', type=str,
                        help='CSV-output file-name.')
    # Parse:
    # ======
    try:
        cli_args = parser.parse_args(sys.argv[1:])
    except Exception as e:
        print("Got '%s' exception - hmmm, how to suppress ...???" % str(e))
    #
    # Process:
    # ========
    if cli_args.map_filename:
        map_file = cli_args.map_filename
    else:
        print("ERROR: a .map-file is required as input!")
        sys.exit(1)
    # We can safely set 'correct_lines' to True here:
    mapinfo_lines = get_text_section_entries(map_file, correct_lines=True)
    link_info = sort_func_entries(mapinfo_lines)
    pretty_print_mapinfo(link_info)
    mlist, mdict = sort_func_entries_by_module_name(link_info)
    u_modules, stdlib_list = pretty_print_by_module_name(mlist, mdict)
    #
    print_total(u_modules, stdlib_list)
    #
    if cli_args.csv_filename:
        dump_mapinfo_to_csv(link_info, cli_args.csv_filename)






